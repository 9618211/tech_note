# SSD的一些原理和特点

[原文](http://www.hellodb.net/2010/10/ssd-database-2.html)


@hellodba

----
##磨损问题:

写入单位page:4K

擦除单位block:512K

擦除代价大 次数有限(不过一般不是个事儿(磨损是不是线性的?))

##SSD硬件层作用:
	
	FTL:物理逻辑地址映射
	Reclamation:回收策略 异步擦除
	Wear leveling:均衡写摩擦,提升寿命
	spare area:减小写入放大,提升写性能

----

##存储技术

`NOR和NAND`

	NOR和NAND都是闪存技术的一种，NOR是Intel公司开发的，它有点类似于内存，允许通过地址直接访问任何一个内存单元，缺点是：密度低（容量小），写入和擦除的速度很慢。NAND是东芝公司开发的，它密度高（容量大），写入和擦除的速度都很快，但是必须通过特定的IO接口经过地址转换之后才可以访问，有些类似于磁盘。

	我们现在广泛使用的U盘，SD卡，SSD都属于NAND类型，厂商将flash memory封装成为不同的接口，比如Intel的SSD就是采用了SATA的接口，访问与普通SATA磁盘一样，还有一些企业级的闪存卡，比如FusionIO，则封装为PCIe接口。

`SLC和MLC`

	SLC是单极单元，MLC是多级单元，两者的差异在于每单元存储的数据量（密度），SLC每单元只存储一位，只包含0和1两个电压符，MLC每单元可以存储两位，包含四个电压符（00,01,10,11）。显然，MLC的存储容量比SLC大，但是SLC更简单可靠，SLC读取和写入的速度都比MLC更快，而且SLC比MLC更耐用，MLC每单元可擦除1w次，而SLC可擦除10w次，所以，企业级的闪存产品一般都选用SLC，这也是为什么企业级产品比家用产品贵很多的原因。

##`SSD的技术特点`##

SSD与传统磁盘相比，第一是没有机械装置，第二是由磁介质改为了电介质。在SSD内部有一个`FTL(Flash Transalation Layer)`，它相当于磁盘中的控制器，主要功能就是作地址映射，将flash memory的物理地址映射为磁盘的LBA逻辑地址，并提供给OS作透明访问。

SSD没有传统磁盘的寻道时间和延迟时间，所以SSD可以提供非常高的随机读取能力，这是它的最大优势，SLC类型的SSD通常可以提供超过35000的IOPS，传统15k的SAS磁盘，最多也只能达到160个IOPS，这对于传统磁盘来说几乎就是个天文数字。SSD连续读的能力相比普通磁盘优势并不明显，因为连续读对于传统磁盘来说，并不需要寻道时间，15k的SAS磁盘，连续读的吞吐能力可以达到130MB，而SLC类型的SSD可以达到170-200MB，我们看到在吞吐量方面，SSD虽然比传统磁盘高一些，但优势虽然并不明显。

SSD的写操作比较特殊，SSD的最小写入单元为4KB，称为页(page)，当写入空白位置时可以按照4KB的单位写入，但是如果需要改写某个单元时，则需要一个额外的擦除（erase）动作，擦除的单位一般是128个page（512KB），每个擦除单元称为块（block）。如果向一个空白的page写入信息时，可以直接写入而无需擦除，但是如果需要改写某个存储单元（page）的数据，必须首先将整个block读入缓存，然后修改数据，并擦除整个block的数据，最后将整个block写入，很显然，SSD改写数据的代价很高，SSD的这个特性，我们称之为erase-before-write。

经过测试，SLC SSD的随即写性能可以达到3000个左右的IOPS，连续写的吞吐量可以达到170-200MB，这个数据还是比传统磁盘高出不少。但是，随着SSD的不断写入，当越来越多的数据需要被改写时，写的性能就会逐步下降。经过我们的测试，SLC在这个方面要明显好于MLC，在长时间写入后，MLC随机写IO下降得非常厉害，而SLC表现则比较稳定。为了解决这个问题，各个厂商都有很多策略来防止写性能下降的问题。

`wear leveling`

因为SSD存在“写磨损”的问题，当某个单元长时间被反复擦写时（比如Oracle redo），不仅会造成写入的性能问题，而且会大大缩短SSD的使用寿命，所以必须设计一个均衡负载的算法来保证SSD的每个单元能够被均衡的使用，这就是wear leveling，称为损耗均衡算法。

Wear leveling也是SSD内部的FTL实现的，它通过数据迁移来达到均衡损耗的目的。Wear leveling依赖于SSD中的一部分保留空间，基本原理是在SSD中设置了两个block pool，一个是free block pool（空闲池），一个是数据池（data block pool），当需要改写某个page时（如果写入原有位置，必须先擦除整个block，然后才能写入数据），并不写入原有位置（不需要擦除的动作），而是从空闲池中取出新的block，将现有的数据和需要改写的数据合并为新的block，一起写入新的空白block，原有的block被标识为invalid状态（等待被擦除回收），新的block则进入数据池。后台任务会定时从data block中取出无效数据的block，擦除后回收到空闲池中。这样做的好处在于，一是不会反复擦写同一个block，二是写入的速度会比较快(省略了擦除的动作)。



Wear leveling分为两种：动态损耗均衡和静态损耗均衡，两者的原理一致，区别在于动态算法只会处理动态数据，比如数据改写时才会触发数据迁移的动作，对静态数据不起作用，而静态算法可以均衡静态数据，当后台任务发现损耗很低的静态数据块时，将其迁移到其他数据库块上，将这些块放入空闲池中使用。从均衡的效果来看，静态算法要好于动态算法，因为几乎所有的block都可以被均衡的使用，SSD的寿命会大大延长，但是静态算法的缺点是当数据迁移时，可能会导致写性能下降。

`写入放大`

因为SSD的erase-before-write的特性，所以就出现了一个写入放大的概念，比如你想改写4K的数据，必须首先将整个擦除块（512KB）中的数据读出到缓存中，改写后，将整个块一起写入，这时你实际写入了512KB的数据，写入放大系数是128。写入放大最好的情况是1，就是不存在放大的情况。

Wear leveling算法可以有效缓解写入放大的问题，但是不合理的算法依然会导致写入放大，比如用户需要写入4k数据时，发现free block pool中没有空白的block，这时就必须在data block pool中选择一个包含无效数据的block，先读入缓存中，改写后，将整个块一起写入，采用wear leveling算法依然会存在写入放大的问题。

通过为SSD预留更多空间，可以显著缓解写入放大导致的性能问题。根据我们的测试结果，MLC SSD在长时间的随机写入后，性能下降很明显（随机写IOPS甚至降低到300）。如果为wear leveling预留更多空间，就可以显著改善MLC SSD在长时间写操作之后的性能下降问题，而且保留的空间越多，性能提升就越明显。相比较而言，SLC SSD的性能要稳定很多（IOPS在长时间随机写后，随机写可以稳定在3000 IOPS），我想应该是SLC SSD的容量通常比较小（32G和64G），而用于wear leveling的空间又比较大的原因。


----


	